# -*- coding: utf-8 -*-
"""2023 basic python thoughtful

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Gkm9fNHZ0tBgRkqufRcX_vzyStJj24_

Still open questions

*   could not print a dictionary {0:1, 1:11, 2:21, 3:31, 4:41}
*   List item
"""



seconds_in_a_day = 24*60*60
seconds_in_a_day

d = {}
type(d)

e = d.fromkeys('ram',[1,2,3])
e

ke, va = 'ram','sam'
f = {k:v for k,v in zip(ke,va)}
list(zip(ke,va))

def f(a,b):
  print('this is a function')
  return a+b
x = f(3,4)
print(f'value of x is {x}')

e = d.fromkeys('ram',1,2,3)
e

d = dict()
d

class Car:
  def __init__(self, make, color, mileage):
    self.make = make
    self.color = color
    self.mileage = mileage

  def me(self):
    print(f'this is a car with make {self.make}, color {self.color}')
    return ({self.make, self.color, self.mileage})

first_car = Car('bmw', 'black', 10)
print(first_car.make)
print(first_car.me)
x = first_car.me()
x

i = 1
while i < 6:
  print(i)
  i += 1
  if i == 3:
    continue

i = 1
while i < 6:
  i += 1
  print(i)
  if i == 3:
    print(i+100)
    continue

def fahrenheit(c):
  f = c*9/5 + 32
  print(f'{c} celsius is {f} fahrenheit')
  return f

k = fahrenheit(38)
k

fahrenheit = lambda c: c*9/5 + 32
fahrenheit(38)

class Dog:
  species = 'Cannis Familiaris'

  def __init__(self, name, age):
    self.name = name
    self.age = age

  def introduce(self):
    print('I am the class dog method to introduce the dog')
    return(f'I am a dog with name {self.name} and age {self.age}')

l = Dog('rana', 5)
print(l.species)
print(l.name)
print(l.age)
print(l.introduce())
print(l.introduce)

import pandas as pd
import numpy as np
a = np.array([[1, 2, 3],
              [4,5,6], [7,8,9]
])
type(a)
a.ndim
df = pd.DataFrame(a)
df

help(np)

dir(np)

help(np.array)

import numpy as np
import pandas as pd
d = {'first_kid_score':[50, np.nan, 60],
     'second_kid_score':[70,90,np.nan],
     'third_kid_score':[np.nan, 99, 95]
    }
df = pd.DataFrame(d)
#print(df )
print(df.isnull)
df.isnull()

class Dog:
  species = 'Cannis Faliaris'
  def __init__(self, name, age):
    self.name = name
    self.age = age

  def description(self):
    print(f'I am describing dog {self.name} and {self.age} ans old with {self.species}')
    return ('I am a god not a dog')

x = Dog('Suraj', 90)
print(x.species)
print(x.description)
print(x.name)
print(x.age)
print(x.description())

class Dog:
  def __str__(self):
    return f'Suraj is a dog'
"""x
print(x)"""

print('Suraj is a thief')
"""print('Suraj is a jerk')
print('suraj fucks for less than 5 minutes')"""

class Car:
  def __init__(self, color, mileage):
    self.color = color
    self.mileage = mileage

  def description(self):
    return f'{self.color} run {self.mileage} per hour'

  def __str__(self):
    return f'{self.color} has a mileage of {self.mileage}'

x = Car('Suraj', 5)
x.description()

import pandas as pd
import numpy as np

a = np.array([
    [1,2,3],
    [10,20,30],
    [100,200,300]
])
print(a)

df = pd.DataFrame(a)
print(df)

d = {
    'first_score': [50, 100, np.nan],
     "second_score" : [70, np.nan, 60],
     "third_score" : [np.nan, 40, 30]
}

d
df1 = pd.DataFrame(d)
df1

d1 = {k:v for k,v in (('first_score', [50, 100, np.nan]),     ("second_score" , [70, np.nan, 60]),     ("third_score" , [np.nan, 40, 30]))}
d1

d2 = dict((('first_score', [50, 100, np.nan]),     ("second_score" , [70, np.nan, 60]),     ("third_score" , [np.nan, 40, 30])))
d2

d3 = {k:v for k,v in enumerate(range(3))}
d3

import pandas as pd
import numpy as np
d2 = dict(
    (
        ('first_score',[20,np.nan, 30]), ("second_kid",[np.nan,60, 80]),("third_kid",[50,60, np.nan])
    )
)
print(d2)
d3 = {k:v for k,v in ((
        ('first_score',[20,np.nan, 30]), ("second_kid",[np.nan,60, 80]),("third_kid",[50,60, np.nan])
    ))}
print(d3)
df = pd.DataFrame(d2)
print(df)
print(df.isnull())
print(df.isna())
print(dir(df))
print()

print(df.dropna())
print(df.describe())
t = enumerate(range(3))
tuple(t)

a = lambda x : x+3
a(5)
u = list(map(int, input().split()))
print('enter your numbers')
u

x = input().split()
print("enter your numbers")
x

def fib(n):
  x,y = 1,1
  for i in range(n):
    y,x = x+y, y
    yield (y)

z = fib(5)
list(z)

def fib(n):
  x, y = 1,1
  for i in range(5):
    y, x = x+y, y
    yield x,y

z = fib(5)
list(z)

count, x, y = 0,0,1
print(count, x, y)
print(x)
while count < 5:
  print(x)
  y, x = x+y, y
  '''print(f'inside loop x is {x} and y is {y}')
  y = x+y
  x = y'''
  print(f'after update x is {x} and y is {y}')
  count = count + 1
  #print(list(x))

# I did it, getting all values of fibbonaci in a list with a while loop
def fibb(n):
  x, y = 0, 1
  yield x
  #for i in range(n):
  i = 0
  while i <n:
    y, x = x+y, y
    yield y
    i += 1


a = fibb(5)
list(a)

# Now I did it, getting all values of fibbonaci in a list with a for loop
def fibb(n):
  x, y = 0, 1
  yield x
  for i in range(n):
    y, x = x+y, y
    yield y
    i += 1


a = fibb(5)
list(a)

# Now have to do it by while loop without function and then using recursion only

x, y = 0,1
i = 0
#n = int(input('enter a value')) wont work in colab so predefining a value of n
n = 5
l = [x]
while i <n:
  y, x = x+y, y
  l.append(y)
  i = i+1
l

# Now have to do it by recursion only

def fibb_rec(n):
  x, y = 0, 1
  yield x
  y, x = x+y, y
  yield y

for i in range(n):
  print(list(fibb_rec(n)))

def factorial(n):
  if n == 1:
    return n
  else:
    return n+factorial(n-1)

print(factorial(3))

def cum(n):
  if n == 1:
    return n
  else:
    return n + cum(n-1)
  # return (n + cum(n-1)) doing this alone gives maximum

print(f'cumulative sum till {5} is {cum(4)}') # need to learn to fill the value of n

x, y = 0,1
def fibb_rec(n):
  if n == 1:
    return [0,1]
  else:
    y, x = x+y, y
    return [x,  ]

x, y = 0, 1
def fibb_rec(n):
  if n <= 1:
    return [x,y]
  else:
    pass
    """yield x
    # y, x = x+y, y"""

    y = x + fibb_rec(n-1)
    return int(y)"""


print(list(fibb_rec(-5)))

def fibb(n):
  x, y = 0,1
  yield x
  for i in range(n):
  #y, x = x+y, y
    x, y = y, x+y
    yield y


list(fibb(5))

n = int(5)
print(n)

x = 1
def fib_rec(n):
  if n<=2:
    return 1
  else:
    return (fib_rec(n-1) + fib_rec(n-2))

print(fib_rec(5))

l = []
for i in range(n):
  l.append(fib_rec(n))
l

#Python program to generate Fibonacci series Program using Recursion
def Fibonacci_series(Number):
  if(Number == 0):
    return 0
  elif(Number == 1):
    return 1
  else:
    return (Fibonacci_series(Number - 2) + Fibonacci_series(Number - 1))

n = 5 #int(input("Enter the value of 'n': "))
print("Fibonacci Series:", end = ' ')
for n in range(0, n):
  print(Fibonacci_series(n), end = ' ')

# solved finally, key is you need only y values to be updated
def fib_rec(n):
  if n <=1:
    return 0
  elif n==2:
    return 1
  else:
    return fib_rec(n-1) + fib_rec(n-2)

l = []
for i in range(8): # google colab does not allow n to be entered from user
  l.append(fib_rec(i))
l

# HCF of two numbers
x, y = 30,45
# smaller of two numbers
n = x if x<y else y
print(f'the smaller number is {n}')

l = []
for i in range(n):
  if x%i ==0 and y%i ==0:
    l.append(i)

print(f'the HCF of {x} and {y} is {l[-1]}')

class Car:
  company = 'skoda'
  def __init__(self, make, model, mileage):
    self.make = make
    self.model = model
    self.mileage = mileage

  def description(self):
    return f'this car is {self.make} of {self.model} and mileage {self.mileage}'

first = Car('Octavia', 2004, 15)
print(first.description())
print(first.company, "\n")

class Old(Car):
  def des_child(self):
    return f'I am the child'

child_1 = Old("fabia", 2002, 10)
print(child_1.des_child())
print(child_1.company)
print(child_1.description)
print(child_1.description())

# HCF of two
x, y = 60, 75
# smaller num
n = x if x<y else y
print(f'smaller is {n}')

l = []
for i in range(1,n):
  if x%i ==0 and y%i == 0:
    l.append(i)

print(f'factors are {l}')
print(f'HCF is {l[-1]}')

"""# dictionary from for loops
d = dict()
for i in range(5):
  for j in range(1,50, 5):
    d[i] = j

print(d)

# dictionary from for loops
d1 = dict()
for i in range(5):
  print(f'i is {i}')
  for j in range(1,50, 10):
    print(f'j is {j}')
  d1[i] = j

print(d1)"""

# dictionary from for loops
d1 = dict()
for i in range(5):
  #print(f'i is {i}')

  for j in range(1,50, 10):
    print(f'i is {i} and j is {j}')
    d1[i] = j

print(d1)

for i in range(1,1000,100):
  print(f'only i is {i}')
  for j in enumerate(range(1,50,10)):
    d[i] = j
    print(f'i is {i} and j is {j}')

d = dict()
for i in range(5):
  for j in range(list('abcde')):
    d[i] = j
print(d)

d = dict()
for i in range(3):
  for j in range(2):
    print(f'i is {i} and j is {j}')
    d[i] = j
    print(f'd is {d}')
print(f'final d is {d}')

d = dict()
for i in range(5):
  for j in range(1,50,10):
    d[i] = j
print(d)
# my logic was right but could not print a dictionary {0:1, 1:11, 2:21, 3:31, 4:41}

d = dict()
d = d.fromkeys('ram','sri')
print(d)

d = d.fromkeys(range(5),"india")
print(d)

d = d.fromkeys(range(5),range(1,50,10))
print(d)

d = {}
d = d.fromkeys(range(5),(lambda x: x*x for x in range(5)))
print(d)

l = []
y = lambda x: x*x
for i in range(5):
  l.append(y(i))
print(l)

print(list(map(lambda x: x*x, range(5))))

d = d.fromkeys(range(5), [0,1,4,9,16])
d

#print a dictionary where keys are integers and values are integer*integer
d = dict()

k1 = [i for i in range(5)]
k2 = [i*i for i in range(5)]

for i in range(5):
  d[k1[i]] = k2[i]

print(d)

#simpler
for i in range(9):
  d[i] = i*i

d

y = lambda x: x*2, range(10)
print(y)
list(y)
#print(y(2)) # tuple object is not callable

z = lambda x: x*3
print(z(3))
print(z(i for i in range(10)))

# lambda for first squaring and then filtering the even squares
l = [i for i in range(10)]
print(l)
sq = list(map(lambda x : x**2, l))
print(sq)
output_bool = list(map(lambda x: x%2==0, sq ))
print(output_bool)
o1 = list(filter(lambda x:x%2==0, sq))
print(o1)

#some short cuts
cube = list(map(lambda x: x**3, [i for i in range(10)]))
print(cube)

filter_cube = list(filter(lambda x:x%2==0,  (map(lambda x:x**3, [i for i in range(10)]))))
filter_cube

#https://stackoverflow.com/questions/72921131/lambda-in-nested-loop-with-condition
a = [[-1,2,-3,4,-5], [10,-20,30,-40]]
"""print(type(a))
# want to cube only positive elements of the list
b = []
for i in a:
  for j in i:
    if j>0:
      b.append(j**3)

print(b)"""

# now list- comprehension
merged = []
for i in a:
  for j in i:
    merged.append(j)
#merged.append([j for i in a]) couldnt do it using list comprehension
print(f'merged list is {merged}')
bl = [i**3 for i in merged if i>0]
print(bl)

# now using list comprehension to try merging
merged_1 = []
merged_1.append(i for i in a)
print(merged_1)
print((j for j in i) for i in a)
merged_1.append((j for j in i) for i in a)
print(merged_1)

# now lambda

# have to do the above example without merging inner lists

a = [1,2,3]
b = [4,5,6]
merged = a+b
print(merged)
#merged_1 = []
merged_1 = a.append(i for i in b) # unable to merge using append
print(merged_1)


c = [[-1,2,-3,4,-5,6],[7,-8,9]]
merged_c1 = [i for i in c]
print(merged_c1)
merged_c2 = [].append(i for i in c)
print(merged_c2)
merged_c = [j for j in i for i in c]
merged_c

d =[[-1,2,-3,4,-5,6],[7,-8,9]]
merged = []
for  i in d:
  #merged = merged + i works fine
  merged += i
print(merged)
print(merged.sort()) # sort is in place and stable but for output you need to print list again
print(merged)
print(merged.reverse())
print(merged)
print(merged.extend(i for i in d)) # understood extend vs append but couldn't learn doing it using list comprehension
print(merged)
merged.extend((j for j in i) for i in d)
print(merged)
merged = [[j for j in i] for i in d] #this is equivalent to matrix
print(merged)
# matrix using list comprehension
matrix = [[j for j in range(3)] for i in range(4)]
print(f'matrix using list comprehension {matrix}')
# learning matrix using for loop
matrix = []
for i in range(3):
  matrix.append(i)
  for j in range(4):
    matrix.append(j)
print(matrix) # similar to merging lists
# so the correct way is
matrix = []
for j in range(4):
  matrix.append([]) # create empty lists in matrix
  print(f'matrix first loop output {matrix}')
  for i in range(3):
    matrix[j].append(i)
    print(f'matrix second loop output {matrix}')
print(matrix)

# list comprehension
l = 'Geeks 4 Geeks'
l = [character for character in l]
print(l)
even = [number for number in range(50) if number%2 ==0]
print(even)
even_odd = [ "even" if i%2==0 else "Odd" for i  in range(10)]
print(even_odd)
multiple_of_5_et_10 = [number for number in range(100) if number%5==0 and number%10==0]
print(multiple_of_5_et_10)
# HCF
a, b = 45,60

# HCF using list comprehension
a,b = 45,75
smaller = a if a<b else b
print(f'smaller of the two numbers is {smaller}')
factors = [number for number in range(1,smaller) if a%number==0 and b%number==0]
print(factors)
print(factors[-1])
# LCM using list comprehension
# first simple logic
greater = a if a>b else b
print(f'greater of the two numbers is {greater}')
lcm = 0
for i in range(greater, 100000):
  if i%a ==  0 and i%b==0:
    #print(i)
    lcm = i
    break
# now list comprehension
lcm = [i for i in range(greater, 1000) if i%a == i%b ==0]
print(f'multiples are {lcm} and lcm is {lcm[0]}')

# prime factorization in python, prime numbers are 2,3,5,7,11,13,17,23 etc i.e. i/%i ==0 only
n = 421

#lets see first if a number is prime
test = [7,10,11]
for number in test:
  for i in range(2,number):
    if number%i == 0:
      print(f'{number} is not a prime number as it got divided by {i}')
      number +=1 # if I dont do it, control will go to else statement and print that 10 is a prime number
    else:
      print(f'{number} is a prime number')
      break # loop is printing 11 twice, need to check it
print("\n")
# lets find prime numbers in a range
prime = []
for number in range(1,10):
  for i in range(2,10):
    if number%i == 0:
      print(f"{number} is not a prime number as it got divided by {i} ")
      number += 1
    else:
      prime.append(number)
      print(f'{number} is a prime number')
      break
print(f"all prime numbers are {prime}")

prime = []
for number in range(1,10):
  for i in range(2,10):
    if number%i == 0:
      print(f"{number} is divisible by {i}")

print("\n, next program")
# if a number is prime or not
number = 57
for i in range(2, number):
  if number%i == 0:
    print(f"{number} is not a prime number as it is divisible by {i}", "\n")
    break
#  else:
 #   print(f"{number} is a prime number, '\n'", " moving on to array case" )
    # else statements prints non intended values so now trying to work on an array and as a workaround save only prime numbers in an output array

test = [29, 31, 51]
prime = []
not_prime = []
for number in test:
  for i in range(2,number):
    if number%i == 0:
      print(f"{number} is not a prime number as it is divisible by {i}")
      not_prime.append(number)
      test.remove(number)
      break
print(not_prime)
print(f"prime series is {test}")
prime = test.remove(not_prime)
print(prime)

# finding all prime numbers in a range
test = [i for i in range(1,15)]
print(test)
print(type(test))
not_prime = []
for number in test:
  for i in range(2,number):
    if number%i ==0:
      print(f"{number} is divisible by {i} so removing {number}")
      not_prime.append(number)
      test.remove(number)
      print(test)
      break #break is required so that we don't test the same number again
print(f"prime numbers in the range are {test}")

# remove all values in a sub set list from a super set list
super_list = [i for i in range(10)]
print(f"super set list is {super_list}")
sub_list = [ i for i in range(10) if i %2==0]
print(f"sub set list is {sub_list}")

# check if sub list is actually a subset of super set list
check_list = []
for i in sub_list:
  if i in super_list:
    check_list.append("Oui")
if len(sub_list) == len(check_list):
  print(f"check list is {check_list}")

# using list-comprehension
odd = [i for i in super_list if i not in sub_list]
print(odd)

#using for loop
for number in sub_list:
  super_list.remove(number)
print(super_list)

# using lambda
output = list(filter(lambda x: x not in sub_list, super_list))
print(f"output list is {output}")

# using sets as sets allow subtraction
set_super = set(super_list)
set_sub = set(sub_list)
print(f" output list using set encoding and decoding is {list(set_super - set_sub)}") # we can use {} in f string to compute an expression

# try - except
for i in sub_list:
  try:
    super_list.remove(i)
  except ValueError:
    pass

print(super_list) # note that these changes are permanent

#classes example for a bank account https://app.box.com/file/1182279991583?sb=/activity

# lets do it for a single account
balance = 0 # global variable

def credit(amount):
  return f"current balance is {balance + amount}"

final = credit(300)
print(f"final balance is {final} euro")

# Now lets make it for multiple users
class Account:
  """ this is saving account of a person """
  def __init__(self, acno, name, date, balance):
    self.acno = acno
    self.balance = balance
    self.name = name
    self.date = date

  def info(self):
    return f'Person {self.name} with account number {self.acno} has balance {self.balance} on {self.date}'

  def update(self, amount, date):
    self.balance = self.balance + amount
    self.date = date
    return f'Balance in account number {self.acno} is {self.balance+ amount} after {self.name}s transaction of {amount} on date {self.date} '

ram = Account(12, 'ram', 'mar 31', 4000)
print(ram.__doc__)
print(ram.acno)
print(ram.info())
print(ram.update(300, "April 3"))
print(ram.update(-500, "April 4"))

# Now have to make account automatically recognize debit and credit and create a fixed deposit account with calculated maturity

class FixedDeposit(Account):
  """ This is fixed deposit account of a person"""
  def __init__(self,  fdbalance, maturitydate, roi):
    self.fdbalance = fdbalance
    self.maturitydate = maturitydate
    self.roi = roi
  def fdmaturity(self):
    maturityamount = self.fdbalance * self.roi * 1/365 # assuming 1 year fd, later update with datetime.datetime
    return f"{Account.self.name} has fd of {self.fdbalance} maturing on {maturitydate} and amount {maturityamount}"

print(f"/n, now lets move to fd")
fdr = FixedDeposit(1000, "jan 20", 7)
fdr.fdmaturity()

class ClassA:
  var1 = 0
  var2 = 0
  def __init__(self):
    ClassA.var1 = 1
    ClassA.var2 = 2

  def methodA(self):
    ClassA.var1 = ClassA.var1 + ClassA.var2
    return ClassA.var1

class ClassB(ClassA):
  def  __init__(self):
    print(f"class A variable 1 when {ClassA.var1}")
    print(ClassA.var2)

object1 = ClassA()
sum = object1.methodA()
object2= ClassB()
sum

#Class1
class Test:
    def __init__(self):
        self.a = 10
        self.b = 20
        self.add = 0

    def calc(self):
        self.add = self.a+self.b

#Class 2
class Test2:
    def display(self):
        print('adding of two numbers: ',self.add)
#creating object for Class1
obj = Test()
#invoking calc method()
obj.calc()
#passing class1 object to class2
Test2.display(obj)

import datetime
class Account:
  name = "Ram"
  def __init__(self, name, acno, balance):
    self.name = name
    self.acno = acno
    self.balance = balance
    self.date = datetime.date(2023,3,31)
  def passbook(self):
    print(f"person {self.name} has balance {self.balance} euros in the account {self.acno} on date{self.date}") # function will output none if you dont return any value
    return   (f"person {self.name} has balance {self.balance} euros in the account {self.acno} on date {self.date}")
  def update(self, transaction, transaction_date):
    self.balance = self.balance + transaction
    self.date = transaction_date
    return f"after transaction of {transaction} euros on {transaction_date} {self.name} has {self.balance}"

person1 = Account("person1", 26560001, 2000 )
print(f" date of person1 {person1.date}")
print(f"passbook of person1 {person1.passbook()}")
print(f"{person1.update(300,datetime.date.today())}") # note that update method updated the balance, now lets create a FD

class FixedDeposit(Account):
  roi = 5.6
  def __init__(self, initial, period):
    self.date = datetime.date.today()
    self.initial = initial
    self.period =  period
    self.roi = FixedDeposit.roi # to access a global variable you need to access it via class name
  def interest(self):
    income = self.initial*self.roi*self.period/36500
    maturity_date = self.date + datetime.timedelta(days=self.period) # add date to days via timedelta(days =)
    maturity_amount = self.initial + income
    return f"{Account.name} has FD maturing on {maturity_date} giving interest {income} and maturity amount {maturity_amount}"

x = FixedDeposit(10000, 365)
x.interest()
# et voila, the problem of FD creation is solved because first you will update account by a credit and then initiate FD account and then update account with a debit

#https://stackoverflow.com/questions/19993795/how-would-i-access-variables-from-one-class-to-another
class A:
  def __init__(self, var1):
    self.var1 = var1
class B:
  def __init__(self, var2):
    self.var2 = var2
class C:
  def sum():
    return a.var1 + b.var2

a = A(1)
print(a.var1)
b = B(10)
print(b.var2)
print(C.sum())

#above stack flow works fine but not it
class A:
  def __init__(self, var1):
    self.var1 = var1
class B:
  def __init__(self, var2):
    self.var2 = var2
class C:
  def __init__(self):
    pass
  def sum(self):
    return a.var1 + b.var2 # note we are accessing instance variables otherwise we get the error that class object doesnt have this attribute

a = A(3)
b = B(5)
#print(f"a.var1 is {a.var1} and b.var2 is {b.var2} and sum from C is {C.sum()}") #TypeError: sum() missing 1 required positional argument: 'self'
# to provide the self, access class by an instance
c = C()
print(f"a.var1 is {a.var1} and b.var2 is {b.var2} and sum from C is {c.sum()}")

#Continuing on above example
# otherwise define the variables in the class, rather than taking from the user, instance must still be created to access them
class A:
  def funa(self):
    A.var1 = "stack"
class B:
  def funb(self):
    B.var2 = "overflow"
class C:
  def sumc(self):
    return A().var1 + B().var2 # Both A.var1 and A().var1 i.e. calling class object and calling instance objects work fine

class D:
  def sumd(self):
    return A.var1 + B.var2

print(f"using instance variables: A().funa is {A().funa()} Bfunb is {B().funb()} and csum is {C().sumc()}")
print(f"class variables now: A().funa is  {A().funa()} Bfunb is {B().funb()} and dsum is {D().sumd()}")

# interaction between classes using super makes all methods and variables of parent class accessible from child
# var1 and var2 is an Instance variables of ClassA. Create an Instance of ClassB and when calling the methodA it will check the methodA in
# Child class (ClassB) first, If methodA is not present in ClassB you need to invoke the ClassA by using the super() method which will
# get you all the methods implemented in ClassA. Now, you can access all the methods and attributes of ClassB.

class A:
  def __init__(self, var1):
    self.var1 = var1
  def methoda(self):
    return f"var1 of class A is {self.var1}"
class B(A): # need to define parent else it wont know which parent to call
  def __init__(self, random1, random2):
    self.random1 = random1
    self.random2 = random2
    super().__init__(3) # you need to provide arguments as listed in parent class
    super().methoda()
  def methodb(self):
    return f"sum is {self.random1} + {self.random2}"

a = A("a")
b = B(2,3)
print(f"var1 of A is {a.var1} and random1, random2 are {b.random1},{b.random2} and sum is {b.methodb()} while methoda called from B is {b.methoda()} ")
print(f"var1 of A is{A().var1} and random1, random2 are {B().random1},{B().random2} and sum is {B().methodb()} while methoda is {B().methoda()} ")

# geeks for geeks example super
class Worker:
  def __init__(self, id, name, add):
    self.id = id
    self.name = name
    self.add = add
  def info_worker(self):
    return f"employee with id {self.id} with name {self.name} and address {self.add}"

class Employee(Worker):
  def __init__(self, id, name, add, email):
    super().__init__(id,name,add) #need to put parenthesis () and no self with super
    self.email = email
    super().info_worker()
  def info_employee(self):
    return f"the above employee has email {self.email}"

w = Worker(1,'name1', 'add1')
e = Employee(10, 'emp1', 'add10', 'emp1@h.com')

print(w.info_worker())
print(e.info_employee())
print(e.info_worker())

class Animal:
  def __init__(self):
    self.legs = 4
    self.domestic = True
    self.tail = True
    self.mammal = True

  def ismammal(self):
    if self.mammal:
      print(f"ismammal method of class Animal")
      return  f"Its a mammal" # cant understand why the function wont return this statement

  def isdomestic(self):
    if self.domestic:
      return f"Its a domestic animal"

class Dog(Animal):
  def __init__(self):
    super().__init__()

  def isdog(self):
    super().ismammal()

  def ispet(self):
    super().isdomestic()

Jackie =  Dog()
print(Jackie.legs)
print(Jackie.isdog()) #the function returns none, answer lies here https://stackoverflow.com/questions/44564414/how-can-i-use-return-to-get-back-multiple-values-from-a-loop-can-i-put-them-i
# answer is using a return inside the loop will break it and exit even if the loop isnt finished
# solution is yield, return via a generator
Jackietype = Jackie.isdog()
print(Jackietype)
print(Jackie.ispet())

cow = Animal
print(cow)
print(cow()) # A class is converted to an object by placing a parenthesis
cow1 = Animal()
print(cow1)

class Animal:
  def __init__(self):
    self.legs = 4
    self.domestic = True
    self.tail = True
    self.mammal = True

  def ismammal(self):
    if self.mammal:
      print(f"ismammal method of class Animal")
      yield  f"Its a mammal" # still returns none

class Dog(Animal):
  def __init__(self):
    super().__init__()

  def isdog(self):
    super().ismammal()

  def ispet(self):
    super().isdomestic()

Jackie =  Dog()
print(Jackie.legs)
print(Jackie.isdog())

# Method Resolution Order, From bottom to top and from left to right

class Mammal:
  def __init__(self, name):
    self.name = name
    print(f"this is mammal class and it is {self.name}")

class FlyAnimal(Mammal):
  def __init__(self, FlyAnimalname):
    super().__init__(FlyAnimalname)

bat = FlyAnimal("bat1")
print(bat, "\n")

class SwimAnimal(Mammal):
  def __init__(self, SwimAnimalname):
    super().__init__(SwimAnimalname)

whale = SwimAnimal("whale1")
print(whale, "\n")

class MixAnimal(FlyAnimal, SwimAnimal):
  def __init__(self, MixAnimalname):
    super().__init__(MixAnimalname)

dove = MixAnimal("Dove1")
print(dove)

print(MixAnimal.__mro__, "\n")
print(MixAnimal.mro())

# Multi inheritance
class Animal:
  def __init__(self, name):
    self.name = name
    print(f"this is {self.name} of animal class")

class CanFly(Animal):
  def __init__(self, canflyname):
    print(f"{canflyname} can fly")
    super().__init__(canflyname)

class CanSwim(CanFly):
  def __init__(self,canswimname):
    print(f"{canswimname} can swim")
    super().__init__(canswimname)

class Mammal(CanSwim):
  def __init__(self,mammalname):
    print(f"{mammalname} is mammal")
    super().__init__(mammalname)

suraj = Mammal("Suraj Suar")
print(suraj)
print(suraj.mro()) #'Mammal' object has no attribute 'mro' as their is no order to decide for method resolution

#https://stackoverflow.com/questions/44564414/how-can-i-use-return-to-get-back-multiple-values-from-a-loop-can-i-put-them-i
a = [alphabet for alphabet in 'abcde']
l1 = [number for number in range(5) ]
d = dict()
d = {k:v for k,v in zip(a,l1)}
print(d)

def show(user_dict):
  for key, value in user_dict.items():
    return(key+key+key+key, value**2) # loop indeed stops after 1 iteration

print(show(d), "\n") # need to put yield statement for function to return all the values

def show1(user_dict):
  for key, value in user_dict.items():
    yield (key+key, value**2)

list(show1(d))

# swap uppercases and lowercases in a string
s = "RaMsInGHtOmaR"
# Method 1: easiest method
s2 = s.swapcase()
print(s2, "\n")

# Method 2: for loop
print(dir(s))
print(f"original s {s} ")
s1 = ""
l = []
s2 = ""
for alphabet in s:
  if alphabet.islower():
    alphabet = alphabet.capitalize()
    s1 = s1 + alphabet # this works fine
    l.append(alphabet) # this works fine too via string to list
  elif alphabet.isupper():
    alphabet = alphabet.lower()
    s1 = s1 + alphabet
    l.append(alphabet)
  else:
    alphabet = alphabet
    s1 = s1 + alphabet
    l.append(alphabet)
for item in l:
  s2 = s2+item
print(f"new s1 {s1}")
print(f"via list to string {s2}")
# or you can do
l2 = []
#and then l2.append say l.append and then rather than the for loop
l2 = "".join(item for item in l) # note the join statement
print(l2)

#Method 3: Function
def swapstringcases(s):
  for alphabet in s:
    if alphabet.isupper():
      alphabet = alphabet.lower()
      # rest you can fill at your

# using list comprehension in place of for loop
print("\n", s)
l3 = [alphabet.lower() if alphabet.isupper() == True else alphabet.upper() for alphabet in s]
print(f"using list comprehension {l3}")
s3 = "".join(item for item in l3)
print(f"string using list comprehension {s3},  '\n'")

#using lambda function in place of for loop
l4 = list(map((lambda alphabet: alphabet.lower() if alphabet.isupper() else alphabet.upper()), s))
s4 = "".join(item for item in l4)
print(f"string using lambda {s4}")

# using list comprehension in a function
print("\n")
def to_alternatecase(string):
  l5 = [alphabet.lower() if alphabet.isupper() else alphabet.upper() for alphabet in s]
  return "".join(item for  item in l5)
x = to_alternatecase(s)
print(f"using list comprehension in a function {x}")

def sum(a,b):
  return a+b

x = sum(3,5)
x

number = 17 # tested both for 17 and 21
# right method
for i in range(2,number):
  if number%i ==0:
    print(f" method 1 {number} gave remainder of {number%i} for {i} so not a prime")
    break
  elif number%i !=0 and i == number-1:
    print(f"{number} is a prime number, '\n' ")
print("\n")

# all prime numbers in a range
upper, l = 23, [1,2]
for number in range(2,upper+1):
  for i in range(2,number):
    if number%i ==0:
      #print(f" method 1 {number} gave remainder of {number%i} for {i} so not a prime")
      break
    elif number%i !=0 and i == number-1:
      l.append(number)
      print(f" l is {l} and {number} is a prime number")

l



import datetime
d = datetime.datetime.today()
print(d)
print(dir(datetime.date))
d1 = datetime.date.today()
print(d1)
d2 = datetime.date(2021,1,13)
print(f"3 {d2}")
(d1-d2).days

import datetime

today_date = datetime.datetime.today().date()
print(today_date)
creation_date = datetime.date(2021,4,5)
print(f"{creation_date}")
duration = today_date - creation_date
print(duration)
print(duration.days)

# wrong method
#classes josiah wong
# Capitalize each word in a string
st = "somewhere on the beach"
print(f" length {len(st)}, type{type(st)}, {st[0]}, st splitted {st.split()}")
l = st.split()
print(l)
u = []
for word in l:
  #word[0] = word[0].upper() TypeError: 'str' object does not support item assignment
  print(word)

# wrong
# Capitalize first alphabet in a string
w = "I want Paris"
u = ""
#concatenate a string
for word in w: # what we are referring as word, is actually alphabet for the string
  print(word)
  u = u + word
  print(u)
u

#concatenate a string
w = "I want Paris"
l = w.split()
#con = str(l) #output['I', 'want', 'Paris']
con = ""
for word in l:
  con = con + word
con



import datetime
d = datetime.date(2013,1,1)
print(d)
aujourdui = datetime.datetime.today()
aujourdui

s = "i want paris"
l = s.split()
#print(len(l))
# make first alphabet upper and then insert whitespace while concatenating list items.
# first concatenating wrong
l1 = []
"""l1[0] = l[0]
l1[1] = " "
l1[2] = l[1]
l1[3] =
"""
l1 = l[0]
for i in range(1, 2*len(l)+1):
  print(f"i in for loop {i}")
  if i % 2 !=0:
    l1[i] = " "
    print(f" l1 inside loop is {l1}")
  else:
    #l1[i] = l[i-2]
    pass
    print("passed")
    print(f" l1 inside loop is {l1}")

  print(f"l1 final {l[i]}")

# correct method for concatenating, still need to do it via for loop
s = "i want paris"
l = s.split()
s1 = " ".join(l)
print(s1) #When joining a string with a dictionary, it will join with the keys of a Python dictionary, not with values.
help(s1.join)

s = "i want paris"
l = s.split()
#for item in l:
#help(enumerate)
l1 = enumerate(l)
print(list(l1))
print(dict(l1))
d = dict(l1)
print(d)
print(d.values())

e = {}
t = tuple(l1)
l3 = list()
for count, element in enumerate(l):
  print(element)
  l2 = list(element)
  l2[0] = l2[0].upper()
  element = "".join(l2)
  print(f"element after processing is {element}")
  l3.append(element)
s1 = " ".join(l3) # here the output does not have an extra space
print(f"desired all uppercase string is {s1}")

s0 = " i want paris"
l0 = s0.split()

sfinal = ""
for element in l0:
  lw = list(element)
  lw[0] = lw[0].upper()
  sw = "".join(lw)
  sfinal = sfinal +  sw + " " # here the output gets an extra space at the end or at the start
print(f"final string with an extra space is {sfinal}")

#alternatively
lfinal = []
for element in l0:
  lw = list(element)
  lw[0] = lw[0].upper()
  sw = "".join(lw)
  lfinal.append(sw)
print(lfinal)
sfinal2 = " ".join(lfinal)
print(f" final proper string is {sfinal2}")

s = "i want paris"
l s.split()

#capitalize first alphabet
s = "jadore"
l = list(s)
print(f"list is {l}")
l[0] = l[0].upper()
s1 = str(l)
print(f"s1 is {s1}")
s = "".join(l)
s

# make a sentence appropriate case

#count the words in a sentence
sen = "i want paris"
l = sen.split()
print(len(l))
# doing it in one line
print(f"number of words in the sentence {sen} are {len(sen.split())}")

#https://www.asc.ohio-state.edu/demarneffe.1/LING5050/material/python2.html
sen = "BF : Check this page out, the professor will lead to cool NLP group at Stanford."
print(f" {len(sen.split())} are total words in this sentence")
l = list(sen.split())
print(l)
print(f"speaker is {l[0]}")
print(f"he said {l[2:]}")
print(f"he said {len(l[2:])} total words")

# find repetitive items and their frequency in a list
sen = "BF : Check this page out, the professor will lead to cool NLP group at Stanford."
l = list(sen)
print(f"length of l is {len(l)}")
s = set(l)
print(f"all alphabets not repeated are {s}")
print(l.count("s"))
for item in s:
  print(f"{item} occurs {l.count(item)} times")

sen = "BF : This Prof demareneffe at ohio state studied NLP at Stanford which is a cool group"
#words
l = list(sen.split())
totalwords = len(l)
print(f"total words spoken by the speaker {l[0]} are {totalwords}")
s = set(l[1:])
print(f"all the words are {s}")
#alphabets
l1 = list(sen)
s1 = set(l1)
print(f"all the alphabets are {s1}")
for item in s1:
  print(f"{item} occurs {l1.count(item)} times and its relative occurence is {l1.count(item)/len(l1)}")

#composition in python means you can access a class as an object in another class, geeks for geeks example
# composition is a HAS-A relationship while inheritance is a IS-A relationship
# basic idea remains same in both composition and inheritance. You provide the class definition with all the arguments though some may come from other classs
# either via instance or via super. Same goes for methods
class First:
  def __init__(self,name):
    self.name = name
    print(f"this is  first class and name is {self.name}")
  def tell(self):
    return f"first class with passenger {self.name}"

new = First("Josiah")
print(new.tell())
print("NOW MOVING TO COMPOSITION, '\n' ")

class Second:
  def __init__(self, address):
    self.name = First("Wong").name
    print("we have initialized first class from second successfully")
    self.address = address
    print(f"this is second class passenger with name {self.name} and address {self.address}")
  def info(self):
    print("Now trying to use methods of first class")
    return First("Sapient").tell()

second = Second("Barclay Road")
print(second)
print(second.info())

#Inheritance or super
class Fruit:
  def __init__(self, taste, shape):
    if self.taste = "sweet" == True:
      self.shape = "does not matter"
      print("we are dealing with a fruit")
  def isfruit(self):
    return (f"a fruit must be {self.taste} and shape {self.shape}")

avacado = Fruit('sweet', "round")
print((avacado.isfruit()))

class Apple:
  def __init__(self, name, dry, sugar):
    self.name = name
    self.sugar = sugar
    self.dry = "True"
  def explain(self):
    return

coffee = ["latte","espresso","bold", "strong", "espresso", "latte", "espresso", "cappacuino", "instant"]
count = 0
for item in coffee:
  if item == "espresso":
    count += 1
print(count)

coffee = ["latte","espresso","bold", "strong", "espresso", "latte", "espresso", "cappacuino", "instant"]
def freq(userlist, item):
  count = 0
  for chaque in userlist:
    if chaque == item:
      count += 1
  return count

x = freq(coffee, "espresso")
print(x)

#now making it with predefined search item

def predef(userlist, item="bold"):
  count1 =  0
  for each in userlist:
    if each==item:
      count1 += 1
  return count1

y = predef(coffee)
print(y)

# or you can use inbuilt count method
def freq_using_count(userlist, to_find="espresso"):
  answer = userlist.count(to_find)
  return answer

z = freq_using_count(coffee)
z

id1 = [("name", "samu"),("phy", 20), ("chem", 30), ("maths", 50)]

idt = tuple(id1)
d1 = dict(idt) # dictionary can be created directly by tuple
print(d1)

d2 = dict(id1) #or from the list only by using dict
print(d2)

d3 = {k:v for k,v in id1}
print(d3)

#optional class attributes https://stackoverflow.com/questions/18087030/how-do-we-get-an-optional-class-attribute-in-python
class OptionalArguments:
  def __init__(self, value, rate=2.7):
    self.value = value
    self.rate = rate
    print(f"user has deposit of {self.value} at rate {self.rate}.")
  def interest(self):
    daily_interest = self.value*self.rate/36500
    return f"daily interest is {daily_interest}"

savings_acc = OptionalArguments(10000)
print(savings_acc.interest())
#print(f"{savings_acc.value} in savings account  {OptionalArguments(10000).interest()} at rate {savings_acc.rate}", "\n" )

deposit_acc = OptionalArguments(10000,6)
print(f"{deposit_acc.value} in deposit account {OptionalArguments(10000,6).interest()} at rate {deposit_acc.rate}")
# open question : why does my class print class print statement twice
# my answer : because it is in class definition so invoked every time class is instantiated

# merge two dictionaries
l = [alphabet for alphabet in "abcde"]
l1 = [alphabet for alphabet in "wxyzu"]
l3 = [number for number in range(4)]
l4 = [number for number in range(100,600,100)]
d = {k:v for k,v in zip(l,l1)}
d2 = {v:k for k,v in zip(l3,l4)}
print(d,"\n", d2 )
print(list(zip(d,d2))) #note that zip method only takes first values and forms tuples out of them thus unsuitable for merging tuples or dictionaries
print(dir(d))
#https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python?rq=1 VERY GOOD RESOURCE
d_merged = d | d2
print(d_merged)

d_mer = {**d, **d2}
print(d_mer)

def merging(x,y):
  z = y.copy() #order doesnt matter so x.copy is also right
  x.update(z)
  return x

d_merg = merging(d,d2)
print(d_merg)

d_merge = {k:v for each in (d,d2) for k,v in each.items()} #PAY ATTENTION
print(d_merge)

# two for loops in one line via dictionary merging above stack flow page
l1 = [alphabet for alphabet in "abcde"]
l2 = [symbol for symbol in "ijkxy"]
l3 = [number for number in range(4)]
l4 = [number for number in range(1000,3000,500)]
d1 = {k:v for k,v in zip(l1,l3)}
print(d1)
d2 = {k:v for k,v in zip(l2,l4)}
print(d2)

d = {k:v for each in (d1,d2) for k,v in each.items()}
d

# dictionary from a list or enumerate
print(enumerate(l1))
print(list(enumerate(l1)))
d = {k:v for k,v in list(enumerate(l1))}
d

#defining method of class in if statement
#Method 1 using inheritance
class Food:
  def __init__(self, food_type):
    self.food_type = food_type
  def is_awesome(self):
    return "is not awesome"

class Cookie(Food):
  def is_awesome(self):
    return "is awesome"

x = Cookie("cookie")
print(x.is_awesome())
y = Food("Cookie")
print(y.is_awesome())
# wants user to instantiate the cookie class if user has chosen cookie

#now method 2
class Food:
  def __init__(self, foodtype):
    self.foodtype = foodtype
  def isawesome(self):
    if self.foodtype == "Cookie":
      return "tres bon"
    else:
      return "pas bien"

x1 = Food("Cookie")
print(x1.isawesome())
x2 = Food("Candy")
print(x2.isawesome())

# using setter method
class Food:
  def __init__(self, food_type):
    self.food_type = food_type
    self.set_awesomeness()
  def set_awesomeness(self):
    if food_type == "Cookie":
      self.set_awesomeness
# not yet completed

#nested classes https://stackoverflow.com/questions/78799/is-there-a-benefit-to-defining-a-class-inside-another-class-in-python

class Upper:
  class Lower1:

#https://python.pages.doc.ic.ac.uk/2022/lessons/core09/02-association/03-dependency.html
class Hero:
  def __init__(self, name, health, strength, defence, luck):
    self.name = name
    self.health = health
    self.strength = strength
    self.defence = defence
    self.luck = luck
  def attack(self, enemy):
    spell_power = self.cast_spell()
    attack_power = self.strength * spell_power
    enemy.reduce_health(attack_power)

  def cast_spell(self, spell_name = "Expluso"):
    if spell_name == "Expluso":
      return 1.2
    else:
      return 1.0

class Food:
  def __init__(self, food_type):
    self.food_type = food_type
  def is_awesome(self):
    quality = self.awesomeness() # we can make a variable to have function's return value as variable's value
    return quality
  def awesomeness(self):
    if self.food_type == "cookie":
      return "is really awesome"
    else:
      return "malad"

x = Food("pizza")
x.is_awesome()

# prime factorization, first find all prime numbers till that number and then divide the number by all of them
# works correct for a single number
user_input = 13

for number in range(2,user_input+1):
  if user_input%number == 0 and number < user_input:
    break
  elif user_input%number !=0:
    pass
  else:
    print(f"a prime number")

#works well to find all prime in a range too

upper = 150
l = []
for number in range(2, upper+1):
  for i in range(2, number+1):
    if number%i ==0 and i<number:
      break
    elif number%i !=0:
      pass
    else:
      l.append(number)
print(l)

#now prime factorization
prime_factors= []
for chaque in l:
  if upper%chaque ==0:
    prime_factors.append(chaque)
prime_factors

#merge two sorted arrays
a,b = "Dickinson","Theodore"
a,b = sorted(a), sorted(b)
print(a,  b)
c = sorted(a+b)
print(c)

#now naive approach using for loops
a = [chaque for chaque in range(6)]
b = [each for each in range(10,30,5)]
s = set()
for i in a:
  s.add(i)
for j in b:
  s.add(j)
import random
l = list(s)
random.shuffle(l)
print(l)

final = []
#def smaller(number):
print(l[:2:])
print(l[:5:])
print(l[2:])
print(l[2])
for i in range(len(l)):
  if l[i] < min(l[i:]):
    final.append(l[i])
final

#shuffle a list without using random

#class method vs instance vs static

#decorators

a = [i for i in range(5)]
b = [j for j in range(50, 10, -9)]
#print(b)
result, merged = [], []
merged = b[4:] + a[:2]+ b[:4] + a[2:]
print(f"{merged} is merged with length {len(merged)}")

"""if merged[0] < min(merged[1:]):
  print(merged[0])
else:
  print(min(merged))
  result.append(min(merged))
  merged.remove(min(merged))
print(result)
print(merged)

for i in range(5):
  result.append(min(merged))
  merged.remove(min(merged))
print(result)
print(merged)

for i in range(10):
  result.append(min(merged))
  merged.remove(min(merged))
print(result)
print(merged)"""

i = 0
while i < (len(merged)): # error was using len(merged)+1
  result.append(min(merged))
  merged.remove(min(merged))
print(result)
print(merged)

# note that while and for loop are essentially similar
#every piece of code is right in this program except that you need to reset output and use only one loop at at time
# since each loop modifies the same lists result and merged

# now doing it without using any builtin functions
#NOT WORKING YET
merged = b[:2] + a[4:] + a[:2]+ b[2:] + a[2:4]
smallest, final = merged[0], []
print(f"smallest before {smallest}")
for i in merged:
  if i < smallest:
    smallest = i
print(f"smallest after {smallest}")
final.append(smallest)
#merged = merged - [smallest] #can not directly subtract one list from another in python
merged = [x for x in merged if x not in final]
print(f"new final is {final} and new original is {merged}") # now need a function to iterate till all elements of merged are sorted

# now using function
merged = b[:2] +a[2:] + b[2:] + a[:2]
print(merged)

def sorting(user_list):
  #final[0] == []
  smallest = user_list[0]
  for i in user_list:
    if i < smallest:
      smallest = i
  user_list = [x for x in user_list if x != smallest]
  final = final[number-1] + [smallest]
  return smallest, user_list, final

for number in range(len(merged)):
  z = sorting(merged)
  smallest, user_list, final = z
print(smallest)
print(user_list)
print(final)

#sort a list without using sorted or inbuilt functions
a, b, l = [number for number in range(6)], [number for number in range(40,30,-2)], []
print(a, b, l)
mix2 = b[2:3]+a[3:]+b[4:]+b[:3]+a[:3] #b[2] gives error can only concatenate lists not int to list
print(mix2)

l = mix2[0:1] #can not do l=mix[0] error int object is not iterable or l+mix[0]
sorted_list = mix2
print(sorted_list)

for element in mix2:
  if l[0] > element:
    l[0] = element
    print(l)

for sorted_list_element in sorted_list:
  for mix2element in mix2:
    if sorted_list_element > mix2element:
      sorted_list_element = mix2element
print(sorted_list)

#sort a list without using sorted or inbuilt functions
a, b, l = [number for number in range(6)], [number for number in range(40,30,-2)], []
print(a, b, l)
mix = b[2:3]+a[3:]+b[4:]+b[:3]+a[:3] #b[2] gives error can only concatenate lists not int to list
print(mix)

final = mix

for element_final in final:
  print(f" finals element before loop is {element_final}")
  for element_mix in mix:
    print("\t", f"mix element is {element_mix}")
    if element_final > element_mix:
      element_final = element_mix
      print("\t", f" finals element after loop is {element_final}")
      mix = [x for x in mix if x not in element_mix]
      print("\t",f"final after iteration is {final}")
print(final)

# correct solution using recursion
def fib(n):
  if n<=0:
    return 0
  elif n == 1:
    return 1
  else:
    return fib(n-1) + fib(n-2)

term, l = 7, []
for i in range(term):
  z = fib(i)
  l.append(z)
print(l)

#correct solution using x, y
def fibb(n, x=0,y=1):
  yield x
  for i in range(n+1):
    y, x = x+y, y
    yield x

n = 7
z = fibb(5)
list(z)



#subtract one list from another in python
a, b = [x for x in range(9)], [x for x in range(7)]
subtraction = [x for x in a if x not in b]
subtraction

# SOME iterations

#one liner
l = [x for x in range(100) if x%2==0 and x%5==0]
print(l)
k = [x for x in range(100) if x%2==0 if x%5==0] # note that you can use two if rather than and if
print(k)

# for loop and while are essentially similar

l = [i for i in range(5)]
for i in range(len(l)):
  l.append()
l

# if in class definition

class Grocery:
  def __init__(self, name, taste, category="Fruit"):
    self.name = name
    if self.category == "Fruit":
      self.taste = taste
  def sweet(self):
    if self.taste == "Sweet":
      return "Fruit is sweet"

eg1 = Grocery("Carrot", "Mixed", category="Mixed2")
eg1.sweet()

l = [3,6,19, 4, 7, 81,2, 83]
l_s = [min(l)]
l= l.remove(min(l))
for i in range(len(l)):
  l_s.append(min(l))
  l = l-l_s
  print(l_s)
l_s

l, n = [], 13
for number in range(1,n+1):
  #print(number)
  for i in range(2, number):
    #print(number, i)
    if number%i == 0 and i < number:
      pass
    else:
      #print(number, i)
      l.append(number)
      pass
l

l, n = [], 13
for number in range(1, n+1):
  for i in range(2, number):
    if number%i == 0:
      break
    l.append(number)
print(l)

l, n = [], 13
for number in range(1, n+1):
  for i in range(2,number):
    if number%i == 0:
      break

  l.append(number)
print(l)

for i in range(1,3):
  print(i)
print('bien')

l = []
n = 3
for number in range(1,n+1):
  for i in range(2,number):
    if number%i == 0:
      break
  l.append(number)
l

for i in range(1,3):
  print(i)
print(i**3)

n = 4
for i in range(2,n):
  if n%i == 0:
    break
print(n)

n = 13
for i in range(2, n):
  if n%i == 0:
    break
  else:
    print(i)

l, n = [], 7
for number in range(1, n+1):
  for i in range(2,number+1):
    if number %i == 0 and i<number:
      break
    else:
      l.append(i)
l

n = 13
i = 2
while i != n:
  if n%i == 0:
    #print()
    break
  else:
    i += 1
  print(i)

n, l = 4, []

l = [n for i in range(2,n) if n%i !=0]
l

def fib(x,y,n):
  x, y = y, x+y
  return x, y

l = []
for i in range(5):
  x, y = fib(1,1,i)
  print(x,y)
  l.append(y)
l

l,n = [], 9
for i in range(2,n):
  if n%i ==0 and i<n:
    print(n,i)
    break
  else:
    print("this",n,i)
    pass
    l.append(n)
    print(l)
l

l, n = [], 5
for i in range(2,n):
  if n%i !=0:
    continue
    l.append(n)
  else:
    break
print(i)
l

l, n = [], 9
for i in range(2,n):
  if n%i != 0:
    continue
  #l.append(n)
  else:
    break
l.append(n)
print(i)
l

l = [n for i in range(2,14) if 13%i!=0]

x, y = 0,1

def fib(x,y, i=0):
  return y,x+y

l= []
for i in range(5):
  fib(x,y,i)
  l.append(y)
l #unable to add recursion to the function

x, y = 0,1

def fib(x,y, i):
  if i ==0:
    return x,y
  else i ==1:
    return x,

n = 5
i =2
while i<n:
  if n%i == 0:
    break
  else:
    i +=1
  if i == n-1:
    print(n)

l, i, n = [], 2, 5
for number in range(1,n+1):
  while i<number:
    if number%i == 0:
      break
    else:
      i+=1
    if i == number-1:
      l.append(number)
  print(l)

